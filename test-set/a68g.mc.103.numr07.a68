# This program is part of the
 
     Revised Mathematisch Centrum Algol 68 Test Set

  by Dick Grune [1979].

  This program is distributed with Algol 68 Genie with
  kind permission of Dick Grune.

  This test set is available from:

     http://www.dickgrune.com/CS/Algol68

  or from the Vrije Universiteit Amsterdam:

     ftp://ftp.cs.vu.nl/pub/dick/Algol68/ #

PR quiet PR

#numr07#
BEGIN #JKok, 730612, test Choleski decomposition#
      OP * = ([] REAL a, b) REAL:
         (REAL s := 0;
          
          FOR i TO UPB a 
          DO s +:= a[i] * b[i]
          OD;
          s);
      
      PROC decsym = (REF [, ] REAL a, REF [] INT p, REAL aux) INT:
           IF INT n = 1 UPB a;
              
              2 UPB a /= n OR UPB p /= n
           THEN 0
           ELSE REAL max := 0, epsnorm, ukk, uki, aii,
                INT pk := 1, r := 0;
                
                PROC ichvec = (REF [] REAL a, b) VOID:
                     IF INT n = UPB a;
                        
                        n > 0
                     THEN [] REAL h = a;
                          
                          a := b;
                          b := h
                     FI
                # interchange two vectors#
                ;
                
                FOR k TO n 
                DO IF a[k, k] > max
                   THEN max := a[k, k];
                        pk := k
                   FI
                OD;
                epsnorm := aux * max;
                FOR k TO n 
                WHILE max > epsnorm
                DO INT k1 = k + 1;
                   
                   p[k] := pk;
                   r := k;
                   IF pk /= k
                   THEN ichvec (a[ : k - 1, k], a[ : k - 1, pk]);
                        ichvec (a[k, k1 : pk - 1], a[k1 : pk - 1, pk]);
                        ichvec (a[k, pk + 1 : ], a[pk, pk + 1 : ]);
                        a[pk, pk] := a[k, k]
                   FI;
                   ukk := a[k, k] := sqrt (max);
                   max := 0;
                   pk := k1;
                   FOR i FROM k1 TO n 
                   DO uki := a[k, i] := (a[k, i] - a[ : k - 1, k] * a[ : k - 1, i]) / ukk;
                      aii := a[i, i] -:= uki * uki;
                      IF aii > max
                      THEN max := aii;
                           pk := i
                      FI
                   OD
                OD;
                r
           FI
      # Choleski decomposition with diagonal pivoting#
      ,
      PROC solsym = ([, ] REAL a, [] INT p, REF [] REAL b) VOID:
           IF INT n = 1 UPB a;
              
              2 UPB a = n AND UPB p = n AND UPB b = n
           THEN INT pk,
                REAL r;
                
                FOR k TO n 
                DO r := b[k];
                   pk := p[k];
                   b[k] := (b[pk] - a[ : k - 1, k] * b[ : k - 1]) / a[k, k];
                   IF pk /= k
                   THEN b[pk] := r
                   FI
                OD;
                FOR k FROM n BY -1 TO 1 
                DO b[k] := (b[k] - a[k, k + 1 : ] * b[k + 1 : ]) / a[k, k]
                OD;
                FOR k FROM n BY -1 TO 1 
                DO IF pk := p[k];
                      pk /= k
                   THEN r := b[k];
                        b[k] := b[pk];
                        b[pk] := r
                   FI
                OD
           FI
      # solution of Choleski decomposed system #
      ;
      
      print (("Value,  expected,  difference", newline, newline));
      FOR n TO 8 
      DO [1 : n, 1 : n] REAL a, aa,
         [1 : n] REAL b, c,
         [1 : n] INT piv;
         
         FOR i TO n 
         DO FOR j TO n 
            DO a[i, j] := aa[i, j] := 1 / (2 * n + 1 - i - j)
            OD
         OD;
         FOR i TO n 
         DO b[i] := 2 ** (n - i)
         OD;
         IF decsym (a, piv, 1e-13) = n
         THEN solsym (a, piv, b);
              FOR i TO n 
              DO print ((aa[i, ] * b, REAL (2 ** (n - i)), aa[i, ] * b - 2 ** (n - i), newline))
              OD
         ELSE print ("Coefficients matrix is not positive definite")
         FI;
         print (newline)
      OD
#Output approximately: 1
                           2  1
                           4  2  1
                           . . .
                           128   64   . . .   1 #
END